# 28. Find the Index of the First Occurrence in a String

Link: https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/
Tags: Two Pointers, String, String Matching
Difficulty: Easy

## 題目解釋
給你兩個字串 `haystack` 和 `needle` ，請你在 `haystack` 字串中找出 `needle` 字串的第一個出現範圍的起始下標（下標從 0 開始）。如果 `needle` 不是 `haystack` 的一部分，則返回 `-1` 。

## 限制與條件
- `1 <= haystack.length, needle.length <= 10^4`
- `haystack` 和 `needle` 僅由小寫英文字符組成

## 解法思路
### 思考過程
這是一個字串匹配的經典問題。最直覺的方法是遍歷 `haystack`，對於每一個可能的起始位置，檢查其後的子字串是否與 `needle` 相匹配。
1. 遍歷 `haystack` 的每個字元。
2. 如果當前字元與 `needle` 的首字元相同，則開始嘗試匹配整個 `needle`。
3. 檢查剩餘字元是否一致。若完全一致，則返回當前的起始下標。
4. 若遍歷結束仍未找到匹配，則返回 -1。

### 解法：Brute Force / Sliding Window
> [!IMPORTANT]
> 思路：遍歷主字串，對每個可能的起始位置進行子字串比對。

### 複雜度分析
| 維度 | 複雜度 | 說明 |
| --- | --- | --- |
| 時間複雜度 | O(n * m) | n 為 haystack 長度，m 為 needle 長度。在最壞情況下需進行多次比對。 |
| 空間複雜度 | O(1) | 僅使用常數額外空間。 |

```cpp
class Solution {
public:
    int strStr(string haystack, string needle) {
        int n = haystack.size();
        int prefix=0, tmp=0;
        int ans=0;
        for (int i=0; i<n; i++){
            if(haystack[i] == needle[0]){
                if(needle.size()==1){
                    return i;
                }
                prefix = i;
                tmp = i+1;
                for (int j=1; j<needle.size(); j++){
                    if (needle[j] == needle[0]){
                        prefix = i+j;
                    }
                    if(haystack[tmp] != needle[j]){
                        break;
                    }
                    if(j == needle.size()-1){
                        return i;
                    }
                    tmp++;
                }
            }
        }
        return -1;
    }
};
```