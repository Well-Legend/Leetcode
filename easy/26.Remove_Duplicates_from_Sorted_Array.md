# 26. Remove Duplicates from Sorted Array

**Link**: https://leetcode.com/problems/remove-duplicates-from-sorted-array/  
**Tags**: Array, Two Pointers  
**Difficulty**: Easy

## 題目解釋
給你一個 **升序排列** 的陣列 `nums` ，請你 **原地** 刪除重複出現的元素，使每個元素 **只出現一次** ，返回刪除後陣列的新長度。元素的 **相對順序** 應該保持 **一致** 。  
不需要考慮陣列中超出新長度後面的元素。

## 限制與條件
- `1 <= nums.length <= 3 * 10^4`
- `-100 <= nums[i] <= 100`
- `nums` 已按升序排列

## 解法思路
### 思考過程
由於陣列已排序，重複的元素一定會相鄰排列。我們可以利用 **雙指針** (Two Pointers) 的技巧：
- `k` 指針：指向當前「已處理好的不重複序列」的下一個存放位置（也代表目前的有效長度）。
- `i` 指針：遍歷整個陣列。
- 我們從第 1 個元素開始遍歷（因為第 0 個元素肯定是不重複的）。
- 當 `nums[i]` 與前一個元素 `nums[i-1]` 不相等時，表示發現了一個新元素。
- 我們將這個新元素填入 `nums[k]` 的位置，並將 `k` 向後移動一格。
- 最終 `k` 的值就是不重複元素的個數。

### 解法：Two Pointers
> [!IMPORTANT]
> 思路：將不重複的元素依序移至陣列前端。

### 複雜度分析
| 維度 | 複雜度 | 說明 |
| --- | --- | --- |
| 時間複雜度 | O(n) | 遍歷陣列一次。 |
| 空間複雜度 | O(1) | 原地修改，不使用額外陣列空間。 |

```cpp
class Solution {
    public:
        int removeDuplicates(vector<int>& nums) {
            int k=1;
            for(int i=1;i<nums.size();i++){
                if(nums[i]!=nums[i-1]){
                    nums[k]=nums[i];
                    k++;
                }
            }
            return k;
        }
    };
```
