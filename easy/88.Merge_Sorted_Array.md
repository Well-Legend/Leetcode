# 88. Merge Sorted Array

**Link**: https://leetcode.com/problems/merge-sorted-array/  
**Tags**: Array, Two Pointers, Sorting  
**Difficulty**: Easy

## 題目解釋
給你兩個按 **非遞減順序** 排列的整數陣列 `nums1` 和 `nums2`，以及兩個整數 `m` 和 `n`，分別表示 `nums1` 和 `nums2` 中的元素數目。  
請你合併 `nums2` 到 `nums1` 中，使合併後的陣列同樣按 **非遞減順序** 排列。  
注意：最終，合併後陣列不應由函數返回，而是存儲在陣列 `nums1` 中。為了應對這種情況，`nums1` 的初始長度為 `m + n`，其中前 `m` 個元素表示應合併的元素，後 `n` 個元素為 `0` ，應忽略。`nums2` 的長度為 `n` 。  

## 限制與條件
- `nums1.length == m + n`
- `nums2.length == n`
- `0 <= m, n <= 200`
- `1 <= m + n <= 200`
- `-10^9 <= nums1[i], nums2[j] <= 10^9`

## 解法思路
### 思考過程
目標是將兩個有序陣列合併。  
代碼中使用了一個直觀的 **輔助陣列法**：  
1. 創建一個臨時陣列 `merged`。  
2. 使用兩個指針 `i` (指向 nums1) 和 `j` (指向 nums2) 同時遍歷。  
3. 比較 `nums1[i]` 和 `nums2[j]`，將較小的放入 `merged` 並移動對應指針。  
4. 將剩餘未遍歷完的元素（無論是 nums1 還是 nums2 的）加入 `merged`。  
5. 最後將 `merged` 的內容複製回 `nums1`。

### 解法：Two Pointers with Auxiliary Array
> [!IMPORTANT]
> 思路：使用額外空間暫存合併結果，確保邏輯簡單清晰。

### 複雜度分析
| 維度 | 複雜度 | 說明 |
| --- | --- | --- |
| 時間複雜度 | O(m + n) | 每個元素各被讀取和寫入一次。 |
| 空間複雜度 | O(m + n) | 使用了額外的 `merged` 陣列。注意：最優解可達 O(1) 空間（從後向前合併）。 |

```cpp
class Solution {
    public:
        void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
            if(m==0){
                for(int i=0; i<n; i++){
                    nums1[i]=nums2[i];
                }
            }
            else if(n==0){}
            else{
                int i=0, j=0;
                vector<int> merged;
                while(i<m && j<n){
                    if(nums1[i]<nums2[j]){
                        merged.push_back(nums1[i++]);
                    }
                    else{
                        merged.push_back(nums2[j++]);
                    }
                }
                while(i<m){
                    merged.push_back(nums1[i++]);
                }
                while(j<n){
                    merged.push_back(nums2[j++]);
                }
                for(int k=0;k<m+n;k++){
                    nums1[k]=merged[k];
                }
            }
        }
    };
```
