# 2529. Maximum Count of Positive Integer and Negative Integer

**Link**: https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/  
**Tags**: Array, Binary Search, Counting  
**Difficulty**: Easy

## 題目解釋
給你一個按 **非遞減順序** 排列的陣列 `nums` ，返回正整數數目和負整數數目中的最大值。  
換句話說，如果 `pos` 表示 `nums` 中正整數的數目，`neg` 表示 `nums` 中負整數的數目，返回 `max(pos, neg)`。  
注意：`0` 既不是正整數也不是負整數。  

## 限制與條件
- `1 <= nums.length <= 2000`
- `-2000 <= nums[i] <= 2000`
- `nums` 按非遞減順序排列

## 解法思路
### 思考過程
因為陣列已經排序，最優解是使用二分搜尋法找到負數和正數的分界點，從而以 O(log n) 時間計算出數量。  
不過，由於本題是「簡單」難度且數據量不大，直接遍歷統計也是完全可行的。  
代碼中採用了直接遍歷的方法：  
- 初始化 `pos` 和 `neg` 為 0。  
- 遍歷陣列，如果元素 `< 0`，`neg++`；如果元素 `> 0`，`pos++`。  
- 最後返回兩者中的較大值。  

### 解法：Linear Scan
> [!IMPORTANT]
> 思路：遍歷陣列，分別統計正數與負數的個數。

### 複雜度分析
| 維度 | 複雜度 | 說明 |
| --- | --- | --- |
| 時間複雜度 | O(n) | 需要完全遍歷陣列一次。 |
| 空間複雜度 | O(1) | 僅使用常數空間。 |

```cpp
class Solution {
    public:
        int maximumCount(vector<int>& nums) {
            int max=0, pos=0, neg=0;
            for(int i=0;i<nums.size();i++){
                if (nums[i]<0)
                    neg++;
                else if (nums[i]>0)
                    pos++;
            }
            if (pos>neg)
                return pos;
            return neg;
        }
    };
```
