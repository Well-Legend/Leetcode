# 14. Longest Common Prefix

Link: https://leetcode.com/problems/longest-common-prefix/
Tags: String
Difficulty: Easy

## 題目解釋
編寫一個函數來查找字串陣列中的最長公共前綴。
如果不存在公共前綴，返回空字串 `""`。

## 限制與條件
- `1 <= strs.length <= 200`
- `0 <= strs[i].length <= 200`
- `strs[i]` 僅由小寫英文字母組成

## 解法思路
### 思考過程
我們可以採用「水平掃描法」。
1. 假設第一個字串 `strs[0]` 為目前的公共前綴 `ans`。
2. 依次遍歷後面的每個字串 `strs[i]`。
3. 對於每個 `strs[i]`，比對它與 `ans` 的公共部分，並更新 `ans` 為這個新的公共部分。
4. 如果在過程中 `ans` 變為空字串，則直接返回。
5. 最終的 `ans` 即為所有字串的公共前綴。

### 解法：Horizontal Scanning
> [!IMPORTANT]
> 思路：兩兩比較，不斷更新公共前綴，直到遍歷完所有字串。

### 複雜度分析
| 維度 | 複雜度 | 說明 |
| --- | --- | --- |
| 時間複雜度 | O(S) | S 是所有字串中字符字符數量的總和。最壞情況下，所有字串都相同，需要比較每個字符。 |
| 空間複雜度 | O(1) | 僅使用常數額外空間存儲結果變數（如果不算結果本身占用的空間）。 |

```cpp
class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        string ans=strs[0];
        for(int i=1; i<strs.size(); i++){
            string prefix;
            for(int j=0; j<strs[i].size(); j++){
                if(ans[j]==strs[i][j]){
                    prefix += strs[i][j];
                }
                else{
                    break;
                }
            }
            ans=prefix;
        }
        return ans;
    }
};
```
