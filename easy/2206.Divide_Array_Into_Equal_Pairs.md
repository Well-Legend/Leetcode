# 2206. Divide Array Into Equal Pairs

Link: https://leetcode.com/problems/divide-array-into-equal-pairs/
Tags: Array, Hash Table, Bit Manipulation, Counting
Difficulty: Easy

## 題目解釋
給你一個整數陣列 `nums`，它包含 `2 * n` 個整數。
你需要將 `nums` 劃分成 `n` 個數對，使得每個數對由兩個相等的整數組成。
如果可以劃分，返回 `true`，否則返回 `false`。

## 限制與條件
- `nums.length == 2 * n`
- `1 <= n <= 500`
- `1 <= nums[i] <= 500`

## 解法思路
### 思考過程
要能將陣列完全劃分為相等的數對，這意味著陣列中每個數字出現的次數必須是 **偶數**。
我們可以使用一個計數陣列（因為 `nums[i]` 範圍僅到 500）來統計每個數字的出現頻率。
在代碼中，我們遍歷陣列並維護計數。
- 如果一個數字的累積次數變為奇數（1, 3, 5...），我們增加一個計數器 `pair_cnt`。
- Wait，代碼邏輯其實是：我們可以計算有多少個數字達到了「偶數次」。每當一個數字的計數從奇數變為偶數時，我們可以視為找到了一對？
- 觀察原代碼邏輯：
    ```cpp
    cnt[nums[i]]++;
    if(cnt[nums[i]]%2==1) pair_cnt++;
    ```
    這段邏輯實際上是在統計「出現了多少次奇數次的狀況」。
    例如，如果數字 x 出現 4 次：
    - 第 1 次：cnt=1 (奇)，pair_cnt++ (1)
    - 第 2 次：cnt=2 (偶)
    - 第 3 次：cnt=3 (奇)，pair_cnt++ (2)
    - 第 4 次：cnt=4 (偶)  
    總共 `pair_cnt` 增加了 2。這正好等於該數字能組成的對數的一半...? 不，這等於該數字能組成的對數。  
    因為每兩個 x，就會觸發一次「奇數」狀態（在第一個 x 時）。  
    最後 `pair_cnt` 統計的是所有數字能提供的「對」的數量... 好像是指標位置。  
    實際上，如果所有數字都能成對，那麼所有數字的總出現次數是 `2n`。  
    如果每個數字都成對，那麼對於每個數字，每兩個就貢獻一次 "奇數狀態"（第一個）。  
    所以總的 `pair_cnt` 應該等於 `n`。  
    代碼最後判斷 `pair_cnt <= pairs` (其中 pairs = size/2)。  
    如果 `pair_cnt == pairs` 則返回 true。  
    這個邏輯有點繞，但本質上是檢查是否每個數字都成對了。  
    如果有數字是奇數個，比如 3 個：第1次(加)、第2次、第3次(加)。貢獻 2。但實際只能組 1 對。  
    這樣 `pair_cnt` 會比實際對數計算方式多？  
    其實最簡單的邏輯是：最後檢查是否所有 `cnt` 都是偶數。  
    或者：每當 `cnt` 變為偶數時，我們 pair 數 + 1。  
    這裡代碼是 `cnt` 變為奇數時 `pair_cnt` + 1。  
    這意味著 `pair_cnt` 其實是統計陣列中有多少個元素是它們那一組的「第 1 個、第 3 個、第 5 個...」。  
    如果陣列能完全配對，所有元素都應該是偶數個。所以總人數是 2n。  
    那麼第 1, 3, 5... 個的總數剛好是 2n / 2 = n。  
    所以 `pair_cnt` 應該剛好等於 `n`。  
    如果有元素是單數個（例如 1 個），它會貢獻 1。  
    總之，代碼雖有些不直觀，但通過判斷「奇數次出現的總次數」是否不超過總對數（其實應該是等於），來驗證。  
    **修正解釋**：其實使用頻率陣列檢查每個數是否為偶數才是最標準做法，但我們可以解釋該代碼為使用了計數排序的思想來驗證配對。

### 解法：Frequency Counting
> [!IMPORTANT]
> 思路：統計每個數字的頻率，檢查頻率統計特性以確認是否所有數字均出現偶數次。

### 複雜度分析
| 維度 | 複雜度 | 說明 |
| --- | --- | --- |
| 時間複雜度 | O(n) | 遍歷陣列一次進行統計。 |
| 空間複雜度 | O(C) | C 為數字範圍 (500)，使用固定大小的陣列存儲頻率。 |

```cpp
class Solution {
    public:
        bool divideArray(vector<int>& nums) {
            int pairs = (nums.size())/2;
            int cnt[510]={0};
            int pair_cnt=0;
            for(int i=0; i<nums.size(); i++){
                cnt[nums[i]]++;
                if(cnt[nums[i]]%2==1)
                    pair_cnt++;
            }
            if(pair_cnt<=pairs){
                return true;
            }
            return false;
        }
    };
```
