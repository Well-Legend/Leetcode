# 2873. Maximum Value of an Ordered Triplet I

**Link**: https://leetcode.com/problems/maximum-value-of-an-ordered-triplet-i/  
**Tags**: Array  
**Difficulty**: Easy

## 題目解釋
給你一個下標從 0 開始的整數陣列 `nums`。  
請你從所有滿足 `i < j < k` 的下標三元組 `(i, j, k)` 中，找出並返回一個下標三元組的值。  
下標三元組 `(i, j, k)` 的值等於 `(nums[i] - nums[j]) * nums[k]`。  
如果所有滿足條件的三元組的值都是負數，則返回 0。  

## 限制與條件
- `3 <= nums.length <= 100`
- `1 <= nums[i] <= 10^6`

## 解法思路
### 思考過程
由於數據範圍非常小（N <= 100），我們可以直接使用 **暴力法**。  
使用三層巢狀迴圈遍歷所有的 `i`, `j`, `k` 組合，約束條件為 `i < j < k`。  
對於每一組，計算 `(nums[i] - nums[j]) * nums[k]` 並更新最大值。  
注意運算過程可能會超過 `int` 範圍（雖然輸入最大 10^6，相乘可能到 10^12），所以使用 `long long` 來存儲結果是必要的。  

### 解法：Brute Force
> [!IMPORTANT]
> 思路：遍歷所有三元組組合找到最大值。

### 複雜度分析
| 維度 | 複雜度 | 說明 |
| --- | --- | --- |
| 時間複雜度 | O(n^3) | 三層巢狀迴圈。對於 N=100，運算次數約 100萬次，非常快。 |
| 空間複雜度 | O(1) | 僅使用常數空間。 |

```cpp
class Solution {
public:
    long long maximumTripletValue(vector<int>& nums) {
        long long max=0;
        for(int i=0; i<nums.size()-2; i++){
            for(int j=i+1; j<nums.size()-1; j++){
                for(int k=j+1; k<nums.size(); k++){
                    if(max < (long long)(nums[i]-nums[j])*nums[k]){
                        max = (long long)(nums[i]-nums[j])*nums[k];
                    }
                }
            }
        }
        return max;
    }
};
```
