# 27. Remove Element

**Link**: https://leetcode.com/problems/remove-element/  
**Tags**: Array, Two Pointers  
**Difficulty**: Easy

## 題目解釋
給你一個陣列 `nums` 和一個值 `val`，你需要 **原地** 移除所有數值等於 `val` 的元素，並返回移除後陣列的新長度。  
元素的順序可以改變。你不需要考慮陣列中超出新長度後面的元素。

## 限制與條件
- `0 <= nums.length <= 100`
- `0 <= nums[i] <= 50`
- `0 <= val <= 100`

## 解法思路
### 思考過程
題目要求原地移除，通常最佳解法是雙指針（一個讀取，一個寫入）。  
不過，本題提供的代碼使用了稍微不同的策略：  
1. 創建一個臨時陣列 `ans`。  
2. 遍歷 `nums`，將所有 **不等於** `val` 的元素存入 `ans`，並計數。  
3. 統計出有多少個元素是被移除的（或直接利用 `cnt`）。  
4. （多餘步驟）去除 `nums` 尾端多餘的空間（`pop_back`）。  
5. 將 `ans` 中的元素覆蓋回 `nums`。  
這雖然不是最優的 O(1) 空間解法，但邏輯正確且符合 Easy 難度的直觀思維。

### 解法：Extra Array Copy
> [!IMPORTANT]
> 思路：篩選出保留元素至新陣列，再複製回原陣列。

### 複雜度分析
| 維度 | 複雜度 | 說明 |
| --- | --- | --- |
| 時間複雜度 | O(n) | 遍歷陣列兩次（篩選和複製）。 |
| 空間複雜度 | O(n) | 使用了與原陣列大小相當的額外空間 `ans`。注意：標準解法應為 O(1)。 |

```cpp
class Solution {
    public:
        int removeElement(vector<int>& nums, int val) {
            vector<int> ans;
            int cut=0, cnt=0;
            for(int i=0; i<nums.size(); i++){
                if(nums[i]!=val){
                    ans.push_back(nums[i]);
                    cnt++;
                }
                else{
                    cut++;
                }
            }
            for(int i=0; i<cut; i++){
                nums.pop_back();
            }
            for(int i=0; i<ans.size(); i++){
                nums[i]=ans[i];
            }
            return cnt;
        }
    };
```
