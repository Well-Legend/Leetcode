# 121. Best Time to Buy and Sell Stock

**Link**: https://leetcode.com/problems/best-time-to-buy-and-sell-stock/  
**Tags**: Array, Dynamic Programming  
**Difficulty**: Easy

## 題目解釋
給定一個陣列 `prices` ，它的第 `i` 個元素 `prices[i]` 表示一支給定股票第 `i` 天的價格。  
你只能選擇 **某一天** 買入這隻股票，並選擇在 **未來的某一個不同的日子** 賣出該股票。設計一個算法來計算你所能獲取的最大利潤。  
如果你不能獲取任何利潤，返回 0 。  

## 限制與條件
- `1 <= prices.length <= 10^5`
- `0 <= prices[i] <= 10^4`

## 解法思路
### 思考過程
我們希望買入價格越低越好，賣出價格越高越好，且賣出必須在買入之後。
最簡單的方法是與歷史最低價比較：
- 遍歷價格陣列，維護一個「到目前為止的最低價格」`buyPrice`。
- 對於每一天，計算如果在該天賣出（即 `current_price - buyPrice`）能獲得的利潤。
- 更新「最大利潤」`profit`。
- 如果當前價格比 `buyPrice` 還低，則更新 `buyPrice`。

### 解法：Greedy (One Pass)
> [!IMPORTANT]
> 思路：在遍歷過程中，隨時記錄歷史最低點，並計算當前價格與最低點的差價來更新最大利潤。

### 複雜度分析
| 維度 | 複雜度 | 說明 |
| --- | --- | --- |
| 時間複雜度 | O(n) | 只需要遍歷陣列一次。 |
| 空間複雜度 | O(1) | 僅使用常數變數存儲最低價與最大利潤。 |

```cpp
class Solution {
    public:
        int maxProfit(vector<int>& prices) {
            int buyPrice = prices[0];
            int profit = 0;
    
            for (int i = 1; i < prices.size(); i++) {
                if (buyPrice > prices[i]) {
                    buyPrice = prices[i];
                }
    
                profit = max(profit, prices[i] - buyPrice);
            }
    
            return profit;        
        }
    };
```
