# 6. Zigzag Conversion

**Link**: https://leetcode.com/problems/zigzag-conversion/  
**Tags**: String  
**Difficulty**: Medium

## 題目解釋
將一個給定字串 `s` 根據給定的行數 `numRows` ，以從上往下、從左到右進行 Z 字形排列。    
之後，你的輸出需要從左往右逐行讀取，產生出一個新的字串，比如：`"PAYPALISHIRING"` 行數為 3 時，排列如下：

```
P   A   H   N
A P L S I I G
Y   I   R
```

之後，輸出應為 `"PAHNAPLSIIGYIR"`。

## 限制與條件
- `1 <= s.length <= 1000`
- `s` 由英文字母（小寫和大寫）、`','` 和 `'.'` 組成
- `1 <= numRows <= 1000`

## 解法思路
### 思考過程
觀察 Z 字形排列的規律：  
1. 字符按照「向下」然後「向上」的順序在各行之間移動。  
2. 當 `numRows = 1` 時，不需做任何變換，直接返回原字串。  
3. 我們可以用一個「週期」的概念：一個完整的 Z 字週期長度為 `cycle = (numRows - 1) * 2`。  
4. 使用一個二維陣列（或多個字串）來模擬每一行的字符收集過程。  
5. 遍歷原字串，根據當前位置在週期中的位置決定放到哪一行，並更新行號（向下或向上）。  
6. 最後將所有行拼接起來即可。  

### 解法：Row Simulation
> [!IMPORTANT]
> 思路：模擬 Z 字形排列過程，用行號指針上下移動來分配字符到對應行。

### 複雜度分析
| 維度 | 複雜度 | 說明 |
| --- | --- | --- |
| 時間複雜度 | O(n) | 遍歷字串一次。 |
| 空間複雜度 | O(n) | 需要額外空間存儲各行的字符。 |

```cpp
class Solution {
public:
    string convert(string s, int numRows) {
        if (numRows == 1) 
            return s;

        int cycle = (numRows-1)*2;
        int n = s.size();
        int row = 0;
        vector<vector<char>> rows(numRows);
        for (int i=0; i<n; i++){
            rows[row].push_back(s[i]);
            if(i%cycle < numRows-1){
                row++;
            } 
            else{
                row--;
            }
        }
        string ans;
        for(auto& r : rows){
            for(char c : r){
                ans += c;
            }
        }
        return ans;
    }
};
```