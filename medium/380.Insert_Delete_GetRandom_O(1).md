# 380. Insert Delete GetRandom O(1)

Link: https://leetcode.com/problems/insert-delete-getrandom-o1/
Tags: Array, Hash Table, Math, Design
Difficulty: Medium

## 題目解釋
實現 `RandomizedSet` 類別：
*   `RandomizedSet()` 初始化 RandomizedSet 對象。
*   `bool insert(int val)` 當元素 `val` 不存在時，向集合中插入該項，並返回 `true` ；否則，返回 `false` 。
*   `bool remove(int val)` 當元素 `val` 存在時，從集合中移除該項，並返回 `true` ；否則，返回 `false` 。
*   `int getRandom()` 隨機返回現有集合中的一項（測試用例保證調用此方法時集合中至少有一個元素）。每個元素應該有 **相同的概率** 被返回。
你必須實現類的函數，使每個函數的 **平均** 時間複雜度為 **O(1)** 。

## 限制與條件
- `-2^31 <= val <= 2^31 - 1`
- 最多調用 `insert`、`remove` 和 `getRandom` 函數 `2 * 10^5` 次
- 在調用 `getRandom` 時，集合中至少有一個元素

## 解法思路
### 思考過程
要實現 O(1) 的插入和刪除，哈希表 (`unordered_map`) 是必須的。
要實現 O(1) 的 `getRandom`（隨機均勻選取），最好使用動態陣列 (`vector`)，因為可以通過下標隨機訪問。
結合這兩者：
- `vector<int> data`：存儲實際數值。
- `unordered_map<int, int> sets`：存儲 `數值 -> data中的索引`。
**Insert**: 檢查 map，不存在則將 `val` 添加到 `vector` 末尾，並在 map 中記錄其索引。
**Remove**: 這是關鍵。要從 `vector` 中刪除一個元素並保持 O(1)，我們不能直接 `erase` 中間的元素（那樣會導致搬移，O(N)）。
技巧是：**交換刪除 (Swap and Pop)**。
1. 從 map 中找到目標 `val` 的索引 `idx`。
2. 將 `vector` 的最後一個元素 `last` 覆蓋到 `idx` 位置。
3. 更新 map 中 `last` 的索引為 `idx`。
4. 刪除 map 中的 `val` 和 `vector` 的最後一個元素。
**GetRandom**: 直接 `data[rand() % data.size()]`。

### 解法：HashMap + Dynamic Array (Swap & Pop)
> [!IMPORTANT]
> 思路：利用 Map 實現快速查找，Array 實現快速隨機，刪除時通過「與末尾交換」來避免數據搬移。

### 複雜度分析
| 維度 | 複雜度 | 說明 |
| --- | --- | --- |
| 時間複雜度 | O(1) | Insert, Remove, GetRandom 平均都是常數時間。 |
| 空間複雜度 | O(n) | 需要存儲所有元素。 |

```cpp
class RandomizedSet {
    private:
        unordered_map<int, int> sets;//<value, data_index>
        vector<int> data;
        int index;
    public:
        RandomizedSet() {
            index=0;
        }
        
        bool insert(int val) {
            if(sets.contains(val)){
                return false;
            }
            sets[val]=index;
            data.push_back(val);
            index++;
            return true;
        }
        
        bool remove(int val) {
            if(sets.contains(val)==false){
                return false;
            }
            int finds = sets[val];
            data[finds]=data[--index];
            data.pop_back();
            sets[data[finds]]=finds;
            sets.erase(val);
            return true;
        }
        
        int getRandom() {
            int idx = rand() % sets.size();
            return data[idx];
        }
    };
```
