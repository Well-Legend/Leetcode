# 55. Jump Game

**Link**: https://leetcode.com/problems/jump-game/  
**Tags**: Array, Dynamic Programming, Greedy  
**Difficulty**: Medium

## 題目解釋
給你一個非負整數陣列 `nums` ，你最初位於陣列的 **第一個下標** 。陣列中的每個元素代表你在該位置可以跳躍的最大長度。  
判斷你是否能夠到達最後一個下標。  

## 限制與條件
- `1 <= nums.length <= 10^4`
- `0 <= nums[i] <= 10^5`

## 解法思路
### 思考過程
我們可以使用貪婪演算法。  
有兩種常見思路：  
1. **向後貪婪**：維護一個 `max_reach`，遍歷陣列，如果當前位置 `i <= max_reach`，則更新 `max_reach = max(max_reach, i + nums[i])`。如果有 `max_reach >= n-1` 則成功。  
2. **向前貪婪**（本代碼所用）：從後往前看，維護一個 `goal`（需要到達的目標，初始為 `n-1`）。  
   - 如果當前位置 `i` 可以跳到 `goal`（即 `i + nums[i] >= goal`），那麼我們只要能到達 `i`，就能到達 `goal`。  
   - 於是將 `goal` 更新為 `i`。  
   - 繼續向前檢查。  
   - 最後如果 `goal` 變成 `0`，說明起點可以到達終點。  

### 解法：Greedy (Backwards)
> [!IMPORTANT]
> 思路：從終點倒推，不斷縮小目標位置。

### 複雜度分析
| 維度 | 複雜度 | 說明 |
| --- | --- | --- |
| 時間複雜度 | O(n) | 遍歷陣列一次。 |
| 空間複雜度 | O(1) | 僅使用常數空間。 |

```cpp
class Solution {
    public:
        bool canJump(vector<int>& nums) {
            int goal = nums.size()-1;
            bool ans = false;
            for(int i=nums.size()-2; i>=0; i--){
                if(i+nums[i]>=goal){
                    goal = i;
                }
            }
            if(goal==0){
                ans = true;
            }
            return ans;
        }
    };
```
