# 167. Two Sum II - Input Array Is Sorted

**Link**: https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/  
**Tags**: Array, Two Pointers, Binary Search  
**Difficulty**: Medium

## 題目解釋
給你一個下標從 1 開始的整數陣列 `numbers` ，該陣列已按 **非遞減順序排列** ，請你從陣列中找出滿足相加之和等於目標數 `target` 的兩個數。  
如果設這兩個數分別是 `numbers[index1]` 和 `numbers[index2]` ，則 `1 <= index1 < index2 <= numbers.length` 。  
以長度為 2 的整數陣列 `[index1, index2]` 的形式返回這兩個整數的下標。  
你可以假設每個輸入 **只對應唯一的答案** ，而且你 **不可以** 重複使用相同的元素。  
你的解決方案必須只使用常數級的額外空間。

## 限制與條件
- `2 <= numbers.length <= 3 * 10^4`  
- `-1000 <= numbers[i] <= 1000`  
- `numbers` 按非遞減順序排列  
- `-1000 <= target <= 1000`  
- 僅存在一個有效答案

## 解法思路
### 思考過程
因為陣列已經排序，這是一個經典的雙指針問題。  
我們可以使用兩個指針，一個指向陣列開頭 `left`，一個指向陣列結尾 `right`。  
1. 計算 `sum = numbers[left] + numbers[right]`。
2. 如果 `sum == target`，找到了答案，返回 `[left+1, right+1]`（題目要求下標從 1 開始）。
3. 如果 `sum < target`，說明當前和太小，我們需要一個更大的數。因為陣列是排序的，移動 `left` 指針向右可以獲得更大的數。
4. 如果 `sum > target`，說明當前和太大，我們需要一個更小的數。移動 `right` 指針向左可以獲得更小的數。
這樣我們可以在一次遍歷中找到答案。

### 解法：Two Pointers
> [!IMPORTANT]
> 思路：利用有序特性，通過雙指針從兩端向中間逼近目標值。

### 複雜度分析
| 維度 | 複雜度 | 說明 |
| --- | --- | --- |
| 時間複雜度 | O(n) | 最壞情況下，左右指針遍歷整個陣列一次。 |
| 空間複雜度 | O(1) | 僅使用常數額外空間。 |

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        vector<int> ans;
        int n =numbers.size();
        int left=0, right=n-1;
        int sum;
        while(left < right){
            sum = numbers[left]+numbers[right];
            if(sum < target){
                left++;
            }
            else if(sum > target){
                right--;
            }
            else{
                ans.push_back(left+1);
                ans.push_back(right+1);
                break;
            }
        } 
        return ans;
    }
};
```