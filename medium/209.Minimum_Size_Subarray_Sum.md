# 209. Minimum Size Subarray Sum

**Link**: https://leetcode.com/problems/minimum-size-subarray-sum/  
**Tags**: Array, Binary Search, Sliding Window, Prefix Sum  
**Difficulty**: Medium

## 題目解釋
給定一個正整數 `target` 與一個由正整數組成的陣列 `nums`。  
找出長度最小的連續子陣列，使其元素總和大於或等於 `target`，並回傳其長度。  
如果不存在符合條件的子陣列，回傳 `0`。

## 限制與條件
- `1 <= target <= 10^9`
- `1 <= nums.length <= 10^5`
- `1 <= nums[i] <= 10^4`

## 解法思路
### 思考過程
因為 `nums[i]` 全是正整數，可以使用雙指針維護一個連續區間 `[left, right]` 與其總和 `sum`。  
你的實作做法是：
1. 一開始讓 `left = right = 0`，`sum = nums[left]`。  
2. 當 `sum >= target`，代表目前區間可行，就更新最短長度 `ans`，再將 `left` 右移縮小視窗。  
3. 當 `sum < target`，就讓 `right` 右移擴張視窗並把新值加到 `sum`。  
4. 若 `right` 已經在尾端且 `sum < target`，代表無法再擴張，直接結束。  

整體是典型滑動視窗，兩個指標都只會往右移動。

### 解法：Sliding Window
> [!IMPORTANT]
> 思路：右指針擴張直到總和達標，左指針收縮以取得最短長度。

### 複雜度分析
| 維度 | 複雜度 | 說明 |
| --- | --- | --- |
| 時間複雜度 | O(n) | 左右指針都只會各走一次陣列。 |
| 空間複雜度 | O(1) | 僅使用常數額外空間。 |

```cpp
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int left=0, right=0;
        int ans=0, sum=nums[left];
        while(left<=right && right<nums.size()){
            if(sum >= target){
                if(ans == 0 || ans > right-left+1){
                    ans = right-left+1;
                }
                sum -= nums[left];
                left++;
            }
            else{
                if(right == nums.size()-1){
                    break;
                }
                right++;
                sum += nums[right];
            }
        }
        return ans;
    }
};
```
