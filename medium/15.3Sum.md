# 15. 3Sum

**Link**: https://leetcode.com/problems/3sum/  
**Tags**: Array, Two Pointers, Sorting  
**Difficulty**: Medium

## 題目解釋
給你一個整數陣列 `nums` ，判斷是否存在三元組 `[nums[i], nums[j], nums[k]]` 滿足 `i != j`、`i != k` 且 `j != k` ，同時還滿足 `nums[i] + nums[j] + nums[k] == 0` 。  
請你返回所有和為 0 且不重複的三元組。  
注意：答案中不可以包含重複的三元組。  

## 限制與條件
- `3 <= nums.length <= 3000`  
- `-10^5 <= nums[i] <= 10^5`  

## 解法思路
### 思考過程
這道題是 Two Sum 的延伸。如果直接暴力三層迴圈，時間複雜度是 O(n^3)，太慢了。  
我們可以先排序，然後利用「固定一個數 + 雙指針找剩餘兩個數」的策略，將複雜度降至 O(n^2)。  
1. 先將陣列排序。  
2. 用 `left` 指針遍歷陣列，作為三元組中的第一個數。  
3. 對剩餘的部分 `[left+1, n-1]`，使用雙指針 `mid` 和 `right` 來尋找和為 `-nums[left]` 的兩個數。  
   - 如果 `sum == 0`，記錄答案。  
   - 如果 `sum < 0`，`mid++`（需要更大的數）。
   - 如果 `sum > 0`，`right--`（需要更小的數）。
4. **去重處理**是本題的關鍵：
   - 找到一組答案後，`mid` 必須跳過所有與當前值相同的元素，避免產生重複三元組。
   - 外層 `left` 移動時，也必須跳過所有與當前值相同的元素。

### 解法：Sorting + Two Pointers
> [!IMPORTANT]
> 思路：排序後固定第一個數，內層使用雙指針從兩端逼近目標和，並在找到答案後跳過重複值。

### 複雜度分析
| 維度 | 複雜度 | 說明 |
| --- | --- | --- |
| 時間複雜度 | O(n^2) | 外層遍歷 O(n)，內層雙指針 O(n)。排序為 O(n log n)，整體受 O(n^2) 主導。 |
| 空間複雜度 | O(1) | 不計算排序的棧空間和結果陣列，僅使用常數額外空間。 |

```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> ans;
        sort(nums.begin(), nums.end());
        int left = 0;
        int mid, right, sum;
        while(left < nums.size()-2){
            mid = left+1;
            right = nums.size()-1;
            while(mid<right){
                sum = nums[left]+nums[mid]+nums[right];
                if (sum == 0){
                    ans.push_back({nums[left], nums[mid], nums[right]});
                    while(nums[mid+1] == nums[mid]){
                        if (mid+1 == right){
                            break;
                        }
                        mid++;
                    }
                    mid++;
                }
                else if (sum < 0){
                    mid++;
                }
                else{
                    right--;
                }
            }
            while(nums[left+1] == nums[left]){
                if(left+1 == nums.size()-2){
                    return ans;
                }
                left++;
            }
            left++;  
        }
        return ans;
    }
};
```