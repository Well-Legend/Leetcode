# 2. Add Two Numbers

**Link**: https://leetcode.com/problems/add-two-numbers/  
**Tags**: Linked List, Math, Recursion  
**Difficulty**: Medium

## 題目解釋
給你兩個 **非空** 的鏈表，表示兩個非負的整數。它們每位數字都是按照 **逆序** 的方式存儲的，並且每個節點只能存儲 **一位** 數字。  
請你將兩個數相加，並以相同形式返回一個表示和的鏈表。  
你可以假設除了數字 0 之外，這兩個數都不會以 0 開頭。  

## 限制與條件
- 每個鏈表中的節點數在範圍 `[1, 100]` 內
- `0 <= Node.val <= 9`
- 題目數據保證列表表示的數字不含前導零

## 解法思路
### 思考過程
這就是標準的加法運算模擬。  
因為數字是逆序存儲的（個位在頭節點），這非常方便我們從低位到高位進行計算。  
我們維護一個進位變數 `overflow`（或 carry）。  
遍歷兩個鏈表：  
1. 取出當前兩個節點的值（如果鏈表已到頭則視為 0）以及進位值求和 `sum`。  
2. 更新進位 `overflow = sum / 10`。  
3. 創建新節點存儲 `sum % 10`。  
4. 移動指標。  
當兩個鏈表都遍歷完後，如果還有進位，記得再創建一個值為 1 的新節點。  

### 解法：Simulation
> [!IMPORTANT]
> 思路：模擬直式加法，注意處理進位和鏈表長度不一致的情況。

### 複雜度分析
| 維度 | 複雜度 | 說明 |
| --- | --- | --- |
| 時間複雜度 | O(max(m, n)) | 時間取決於較長的那個鏈表。 |
| 空間複雜度 | O(1) | 不計算返回結果所佔用的空間（這是必需的），只使用常數輔助變數。 |

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
    public:
        ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
            if (l1 == NULL) return l2;
            if (l2 == NULL) return l1;
            ListNode* temp = new ListNode(-1);
            ListNode* head = temp;
            int overflow = 0;
            while (l1 != NULL || l2 != NULL) {
                int sum = overflow;
                if (l1 != NULL) {
                    sum += l1->val;
                    l1 = l1->next;
                }
                if (l2 != NULL) {
                    sum += l2->val;
                    l2 = l2->next;
                }
                overflow = sum/10;
                temp->next = new ListNode(sum%10);
                temp = temp->next;
            }
    
            if (overflow != 0) {
                temp->next = new ListNode(overflow);
            }
            return head->next;
        }
    };
```
