# 189. Rotate Array

Link: https://leetcode.com/problems/rotate-array/
Tags: Array, Math, Two Pointers
Difficulty: Medium

## 題目解釋
給定一個整數陣列 `nums`，將陣列中的元素向右輪轉 `k` 個位置，其中 `k` 是非負數。

## 限制與條件
- `1 <= nums.length <= 10^5`
- `-2^31 <= nums[i] <= 2^31 - 1`
- `0 <= k <= 10^5`
- Follow up: Try to come up with as many solutions as you can. Could you do it in-place with O(1) extra space?

## 解法思路
### 思考過程
要原地旋轉陣列，有一個非常巧妙的算法，稱為 **三次翻轉法** (Reverse Strategy)。
觀察陣列 `[1,2,3,4,5,6,7]` 和 `k=3` -> 結果 `[5,6,7,1,2,3,4]`。
可以發現：
1. 原陣列的後 `k` 個元素 `[5,6,7]` 移到了最前面。
2. 原陣列的前 `n-k` 個元素 `[1,2,3,4]` 移到了後面。
3. 但這兩部分內部的順序保持不變。
操作步驟：
1. 首先將 **整個陣列** 翻轉：`[7,6,5,4,3,2,1]`。
2. 然後翻轉 **前 k 個** 元素：`[5,6,7, 4,3,2,1]`。
3. 最後翻轉 **剩餘的 n-k 個** 元素：`[5,6,7, 1,2,3,4]`。
這樣就得到了正確的結果，且不需要額外空間。
注意：`k` 可能大於陣列長度，所以第一步是 `k %= nums.size()`。

### 解法：Array Reversal
> [!IMPORTANT]
> 思路：透過三次局部或整體的翻轉操作，改變元素的相對位置。

### 複雜度分析
| 維度 | 複雜度 | 說明 |
| --- | --- | --- |
| 時間複雜度 | O(n) | 每個元素被翻轉兩次（一次全域，一次局部），總體線性時間。 |
| 空間複雜度 | O(1) | 原地操作。 |

```cpp
class Solution {
    public:
        void rotate(vector<int>& nums, int k) {
            k = k%nums.size();
            reverse(nums.begin(), nums.end());
            reverse(nums.begin(), nums.begin()+k);
            reverse(nums.begin()+k, nums.end());
        }
    };
```
