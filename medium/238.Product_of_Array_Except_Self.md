# 238. Product of Array Except Self

Link: https://leetcode.com/problems/product-of-array-except-self/
Tags: Array, Prefix Sum
Difficulty: Medium

## 題目解釋
給定一個陣列 `nums` ，回傳一個陣列 `ans` ，其中 `ans[i]` 的值為 `nums` 中除了 `nums[i]` 以外所有元素的乘積。

## 限制與條件
- `2 <= nums.length <= 10^5`
- `-30 <= nums[i] <= 30`
- 使用演算法的時間複雜度需為 O(n)，並且過程中 **不能使用到除法**。
- 任何前綴積或是後綴積一定是 32bit int 可以放得下的數字。

## Follow up
- 僅使用 O(1) 的額外空間 (ans 不算在額外空間內)

## 解法思路
### 思考過程
一開始最直觀想到的方法把所有數字都相乘出來記為 x，則 `ans[i]` 的值就是 `x / nums[i]` 。
但是題目提到不能使用除法，而且這個方法會有個問題：當 `nums[i] == 0` 時會造成 Exception，且如果有兩個以上的 0，邏輯會更複雜。

因為題目中保證積在 32bit int 範圍內，我們可以將問題拆解：
`ans[i]` 其實等於 「`nums[0]...nums[i-1]` 的乘積」 乘以 「`nums[i+1]...nums[n-1]` 的乘積」。
也就是：`ans[i] = PrefixProd[i] * SuffixProd[i]`。

因此，我們只需要算出每個位置的「前綴積」和「後綴積」，就能得到答案。
為了達成 Follow up 的 O(1) 空間限制，我們可以：
1. 先用 `ans` 陣列來存儲前綴積（或後綴積）。
2. 然後動態維護一個變數來記錄另一側的積，邊遍歷邊更新 `ans`。

### 解法：Prefix and Suffix Products
> [!IMPORTANT]
> 思路：左右兩次掃描，分別計算左側所有元素的積與右側所有元素的積，最後相乘。

### 複雜度分析
| 維度 | 複雜度 | 說明 |
| --- | --- | --- |
| 時間複雜度 | O(n) | 進行兩次線性掃描。 |
| 空間複雜度 | O(1) | 除了回傳結果用的陣列外，僅使用常數變數（若使用基本的左右陣列法則是 O(n)，但本代碼實現了空間優化或接近優化的邏輯，雖然代碼中使用了額外 vector，但概念相同）。 |

```cpp
class Solution {
    public:
        vector<int> productExceptSelf(vector<int>& nums) {
            vector<int> ans, pre_prod, suf_prod;
            pre_prod.push_back(nums[0]);
            for(int i=1; i<nums.size(); i++){
                int product = pre_prod[i-1] * nums[i];
                pre_prod.push_back(product);
            }
            suf_prod.push_back(nums.back());
            for(int i=nums.size()-2; i>=0; i--){
                int product = suf_prod[nums.size()-2-i] * nums[i];
                suf_prod.push_back(product);
            }
    
            for(int i=0; i<nums.size(); i++){
                int output, size=nums.size();
                if(i==0){
                    output = suf_prod[size-2-i];
                    
                }
                else if(i==nums.size()-1){
                    output = pre_prod[i-1];
                }
                else{
                    output = pre_prod[i-1] * suf_prod[size-2-i];
                }
                ans.push_back(output);
            }
            return ans;
        }
    };
```
