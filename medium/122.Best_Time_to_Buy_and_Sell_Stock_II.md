# 122. Best Time to Buy and Sell Stock II

Link: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/
Tags: Array, Dynamic Programming, Greedy
Difficulty: Medium

## 題目解釋
給你一個整數陣列 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的價格。
在每一天，你可以決定是否購買和/或出售股票。你在任何時候 **最多** 只能持有一股 股票。你也可以先購買，然後在 **同一天** 出售。
返回 你能獲得的 **最大** 利潤 。

## 限制與條件
- `1 <= prices.length <= 3 * 10^4`
- `0 <= prices[i] <= 10^4`

## 解法思路
### 思考過程
這是一個典型的貪婪問題。
因為不限制交易次數，只要明天的價格比今天高，我們就可以在今天買入、明天賣出，獲取這部分的差價利潤。
即使是連續上漲（例如 1 -> 5 -> 10），「1買5賣」再「5買10賣」的總利潤 (4+5=9)，等同於「1買10賣」(9)。
所以，我們只需遍歷陣列，累加所有 `prices[i] > prices[i-1]` 的正向差值即可。
代碼邏輯略有不同但等效：維護一個 `buy_price`，一旦發現當前價格高於 `buy_price`，就結算利潤並將 `buy_price` 更新為當前價格（相當於賣出後立即以當前價買回，或者單純視為更新了成本價以計算下一段利潤）。如果當前價格低於 `buy_price`，則更新 `buy_price` 為更低的價格（買入更便宜）。

### 解法：Greedy (Total Variation)
> [!IMPORTANT]
> 思路：累加所有上漲波段的利潤。只要 `prices[i] > prices[i-1]`，就將差價計入總利潤。

### 複雜度分析
| 維度 | 複雜度 | 說明 |
| --- | --- | --- |
| 時間複雜度 | O(n) | 遍歷陣列一次。 |
| 空間複雜度 | O(1) | 僅使用常數空間。 |

```cpp
class Solution {
    public:
        int maxProfit(vector<int>& prices) {
            int profit=0, buy_price=prices[0];
            for(int i=1; i<prices.size(); i++){
                if(prices[i]>buy_price){
                    profit+=prices[i]-buy_price;
                    buy_price=prices[i];
                }
                else{
                    buy_price=prices[i];
                }
            }
            return profit;
        }
    };
```
