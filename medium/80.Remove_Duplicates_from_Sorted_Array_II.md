# 80. Remove Duplicates from Sorted Array II

Link: https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/
Tags: Array, Two Pointers
Difficulty: Medium

## 題目解釋
給你一個有序陣列 `nums` ，請你 **原地** 刪除重複出現的元素，使得出現次數超過兩次的元素 **只出現兩次** ，返回刪除後陣列的新長度。
不要使用額外的陣列空間，你必須在 **原地** 修改輸入陣列 并在使用 O(1) 額外空間的條件下完成。

## 限制與條件
- `1 <= nums.length <= 3 * 10^4`
- `-10^4 <= nums[i] <= 10^4`
- `nums` 已按升序排列

## 解法思路
### 思考過程
這是「刪除重複項」問題的通用版（允許最多 k 次）。
使用雙指針：
- `k`：指向下一個放置元素的位置。
- `i`：遍歷陣列。
基本核心邏輯：對於當前元素 `nums[i]`，如果它 **應該被保留**，則 `nums[k++] = nums[i]`。
什麼時候應該被保留？
1. 如果 `k < 2`，前兩個元素肯定保留。
2. 如果 `nums[i] != nums[k-2]`，說明它與 **倒數第二個已保留的元素** 不同，那麼即使它與由 `nums[k-1]` 相同，它也是該數字的第 2 個（允許的），或者它是全新的數字。
   - 如果 `nums[i] == nums[k-2]`，說明這是該數字的第 3 個（或更多），因為陣列有序，`nums[k-2] == nums[k-1] == nums[i]`。這時應忽略。

本題代碼採用了計數器 `cnt` 的方式：
- 記錄當前元素重複次數。
- 如果是新元素，重置 `cnt=1`，保留。
- 如果是舊元素且 `cnt < 2`（即 `cnt` 變為 2），保留。
- 否則忽略。

### 解法：Twos Pointers with Counter
> [!IMPORTANT]
> 思路：利用計數器或比較回溯位置，確保每個元素最多只保留兩個。

### 複雜度分析
| 維度 | 複雜度 | 說明 |
| --- | --- | --- |
| 時間複雜度 | O(n) | 遍歷陣列一次。 |
| 空間複雜度 | O(1) | 原地操作。 |

```cpp
class Solution {
    public:
        int removeDuplicates(vector<int>& nums) {
            int k=1, cnt=1;
            for(int i=1; i<nums.size(); i++){
                cnt++;
                if(nums[i]!=nums[i-1]){
                    nums[k]=nums[i];
                    k++;
                    cnt=1;
                }
                else if(cnt==2){
                    nums[k]=nums[k-1];
                    k++;
                }
            }
            return k;
        }
    };
```
