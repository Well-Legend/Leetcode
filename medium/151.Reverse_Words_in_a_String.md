# 151. Reverse Words in a String

**Link**: https://leetcode.com/problems/reverse-words-in-a-string/  
**Tags**: String, Two Pointers, Stack  
**Difficulty**: Medium

## 題目解釋
給你一個輸入字串 `s`，請你反轉字串中 **單詞** 的順序。  
單詞是由非空格字符組成的字串。`s` 中使用至少一個空格將字串中的單詞分隔開。  
返回單詞順序顛倒且單詞之間用單個空格連接的結果字串。  
注意：輸入字串 `s` 中可能會存在前導空格、尾隨空格或者單詞之間的多個空格。返回的結果字串中，單詞間應當僅用單個空格分隔，且不包含任何額外的空格。

## 限制與條件
- `1 <= s.length <= 10^4`
- `s` 包含英文大小寫字母、數字和空格 `' '`
- `s` 中至少存在一個單詞

## 解法思路
### 思考過程
這道題的核心是「反轉單詞順序」但「保持單詞內部字符順序不變」，同時處理多餘的空格。  
常見的解法有兩種：
1. **雙指針/迭代**：從後往前遍歷字串，識別出每個單詞並拼接到結果中。
2. **堆疊 (Stack)**：利用堆疊「後進先出」的特性。我們先遍歷字串，將單詞一個個讀出來放入堆疊，最後再從堆疊中彈出，自然的就完成了順序的反轉。

本題的code使用了堆疊 (`stack`) 的思路來輔助處理字符與空格的關係。  
（註：這份代碼使用了兩個字符堆疊 `tmp` 和 `reverse_tmp` 來進行字符級別的操作與緩衝，邏輯較為獨特。一般常見做法是直接分割單詞入堆疊）。

### 解法：Stack Simulation
> [!IMPORTANT]
> 思路：利用堆疊暫存字符或單詞，藉此改變輸出的順序。

### 複雜度分析
| 維度 | 複雜度 | 說明 |
| --- | --- | --- |
| 時間複雜度 | O(n) | 遍歷字串處理每個字符。 |
| 空間複雜度 | O(n) | 使用了額外的堆疊空間來存儲字符。 |

```cpp
class Solution {
    public:
        string reverseWords(string s) {
            stack<char> tmp;
            stack<char> reverse_tmp;
            string ans;
    
            for (int i=0; i<s.size(); i++){
                if (s[i]==' '){
                    while (!tmp.empty()){
                        reverse_tmp.push(tmp.top());
                        tmp.pop();
                    }
                }
                else{
                    if(tmp.empty()){
                        tmp.push(' ');
                    }
                    tmp.push(s[i]);
                }
            }
            while (!tmp.empty()){
                reverse_tmp.push(tmp.top());
                tmp.pop();
            }
            if (reverse_tmp.top() == ' '){
                reverse_tmp.pop();
            }
            int n = reverse_tmp.size();
            for (int i=0; i<n; i++){
                ans += reverse_tmp.top();
                reverse_tmp.pop();
            }
            return ans;
        }
    };
```