# 2563. Count the Number of Fair Pairs

Link: https://leetcode.com/problems/count-the-number-of-fair-pairs/
Tags: Array, Two Pointers, Binary Search, Sorting
Difficulty: Medium

## 題目解釋
給你一個下標從 0 開始、長度為 `n` 的整數陣列 `nums` ，和兩個整數 `lower` 和 `upper` ，返回 **公平數對的數目** 。
如果 `(i, j)` 滿足 `0 <= i < j < n` 且 `lower <= nums[i] + nums[j] <= upper` ，則稱為 **公平數對** 。

## 限制與條件
- `1 <= nums.length <= 10^5`
- `nums[i]` 取值範圍較大，相加可能溢出 `int`，雖然 C++ `long long` 可解。
- `lower, upper` 範圍

## 解法思路
### 思考過程
題目要求滿足條件的 `(i, j)` 對數。
直接暴力兩層循環是 O(n^2)，會超時（N=10^5）。
我們可以先將陣列 **排序**。排序後不影響數對的數量（因為題目只關心數值對，不要求原始下標順序，或者說题目是 "i < j"，排序後只要找到任意兩個數滿足和的條件即可？Wait, `0 <= i < j < n` 的條件是基於索引的。但 "pairs" 的值只依賴於 `nums` 的值。對於 "count pairs with i < j"，如果我們打亂順序，只要我們計算的是「任意兩個數的組合」，結果是一樣的。例如 [1, 7] 和 [7, 1] 是一樣的組合。排序後我們統計滿足條件的下標對 `(p, q)` with `p < q`，這些對應的數值組合其實就是原陣列中的數值組合。所以排序是安全的。）

排序後，對於每個 `nums[i]`，我們需要找到 `j > i` 使得 `lower - nums[i] <= nums[j] <= upper - nums[i]`。
這是一個典型的區間查找問題。
因為 `nums` 剩餘部分是有序的，我們可以使用 **二分搜尋** (`lower_bound` 和 `upper_bound`) 來快速找到滿足條件的 `nums[j]` 的範圍。
範圍的大小就是該 `i` 對應的配對數。

### 解法：Sorting + Binary Search
> [!IMPORTANT]
> 思路：固定一個數，利用二分搜尋在有序陣列中查找另一個數的合法範圍。

### 複雜度分析
| 維度 | 複雜度 | 說明 |
| --- | --- | --- |
| 時間複雜度 | O(n log n) | 排序需要 O(n log n)，遍歷並二分搜尋需要 O(n log n)。 |
| 空間複雜度 | O(1) | 依賴排序算法的空間。 |

```cpp
class Solution {
    public:    
        long long countFairPairs(vector<int>& nums, int lower, int upper) {
            long long pairs=0;
            //sort
            sort(nums.begin(), nums.end());
    
            //main
            for(int i=0; i<nums.size()-1; i++){
                int up_bound = upper_bound(nums.begin() + i + 1, nums.end(), upper-nums[i])-nums.begin();
                int low_bound = lower_bound(nums.begin() + i + 1, nums.end(), lower-nums[i])-nums.begin();
                pairs += (up_bound-low_bound);
            }
            return pairs;
        }
    };
```
