# 45. Jump Game II

**Link**: https://leetcode.com/problems/jump-game-ii/  
**Tags**: Array, Dynamic Programming, Greedy  
**Difficulty**: Medium

## 題目解釋
給定一個長度為 `n` 的 0 索引整數陣列 `nums`。初始位置為 `nums[0]`。  
每個元素 `nums[i]` 表示從索引 `i` 向前跳轉的 **最大長度**。  
返回到達 `nums[n - 1]` 的 **最小跳躍次數**。生成測試用例可以到達 `nums[n - 1]`。  

## 限制與條件
- `1 <= nums.length <= 10^4`
- `0 <= nums[i] <= 1000`

## 解法思路
### 思考過程
這可以看作是 BFS（廣度優先搜索）的一種貪婪優化。  
我們不需要維護一整個隊列，只需要維護當前步數能到達的範圍 `[near, far]`。  
第 0 步：範圍 `[0, 0]`。  
第 1 步：遍歷第 0 步範圍內每個點能到達的最遠位置，記為 `new_far`。新的範圍變成 `[far + 1, new_far]`。  
以此類推，每遍歷完當前層的所有節點，跳躍次數 `jumps` 加 1，並把範圍擴展到下一層。  
直到 `far` 覆蓋了終點 `n-1`。  

### 解法：Implicit BFS (Greedy)
> [!IMPORTANT]
> 思路：每次跳躍都盡可能延伸到最遠邊界，區間推進。

### 複雜度分析
| 維度 | 複雜度 | 說明 |
| --- | --- | --- |
| 時間複雜度 | O(n) | 每個元素最多被訪問一次。 |
| 空間複雜度 | O(1) | 僅使用常數變數。 |

```cpp
class Solution {
    public:
        int jump(vector<int>& nums) {
            int near = 0, far = 0, jumps = 0;
    
            while (far < nums.size() - 1) {
                int farthest = 0;
                for (int i = near; i <= far; i++) {
                    farthest = max(farthest, i + nums[i]);
                }
                near = far + 1;
                far = farthest;
                jumps++;
            }
    
            return jumps;
        }
};
```
