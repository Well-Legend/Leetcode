# 3. Longest Substring Without Repeating Characters

**Link**: https://leetcode.com/problems/longest-substring-without-repeating-characters/  
**Tags**: Hash Table, String, Sliding Window  
**Difficulty**: Medium

## 題目解釋
給定一個字串 `s`，請找出不含重複字元的最長子字串長度。  
子字串必須是連續區間。

## 限制與條件
- `0 <= s.length <= 5 * 10^4`
- `s` 由英文字母、數字、符號與空白組成

## 解法思路
### 思考過程
你的程式碼使用滑動視窗搭配 `unordered_set<char>`：
1. `left` 與 `right` 維護目前視窗 `[left, right]`。  
2. 如果 `s[right]` 不在集合中，就放入集合，並更新最長長度。  
3. 如果 `s[right]` 已存在，代表有重複，就持續移動 `left`，把左邊字元從集合移除，直到 `s[right]` 可加入為止。  
4. 每輪最後讓 `right` 往右走，繼續擴張視窗。  

這樣可以確保集合始終對應到「當前無重複字元的視窗」。

### 解法：Sliding Window + Hash Set
> [!IMPORTANT]
> 思路：右指針擴張、遇重複時左指針收縮，維持視窗內字元唯一。

### 複雜度分析
| 維度 | 複雜度 | 說明 |
| --- | --- | --- |
| 時間複雜度 | O(n) | 每個字元最多被右指針加入一次、被左指針移除一次。 |
| 空間複雜度 | O(min(n, 字元集大小)) | 集合儲存目前視窗內的字元。 |

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_set<char> sub;
        int left=0, right=0, n=s.size();
        int length=0;
        while(right<n){
            if(sub.count(s[right]) == 0){
                sub.insert(s[right]);
                length = max(length, right-left+1);
            }
            else{
                while(sub.count(s[right]) != 0){
                    sub.erase(s[left]);
                    left++;
                }
                sub.insert(s[right]);
            }
            right++;
        }
        return length;
    }
};
```
