# 42. Trapping Rain Water

**Link**: https://leetcode.com/problems/trapping-rain-water/  
**Tags**: Array, Two Pointers, Dynamic Programming, Stack  
**Difficulty**: Hard

## 題目解釋
給定 `n` 個非負整數表示每個寬度為 1 的柱子的高度圖，計算按此排列的柱子，下雨之後能接多少雨水。

## 限制與條件
- `n == height.length`
- `1 <= n <= 2 * 10^4`
- `0 <= height[i] <= 10^5`

## 解法思路
### 思考過程
這是一個經典的接雨水問題。  
對於任意一個位置 `i`，它能接到的雨水量取決於它左邊最高的柱子 `left_max` 和右邊最高的柱子 `right_max`。  
具體來說，位置 `i` 的蓄水量 = `min(left_max, right_max) - height[i]`。  
如果我們對每個位置都單獨去尋找它的左右最大值，時間複雜度會是 O(n^2)。  
我們可以優化這過程：  
1. **動態規劃**：預先計算好每個位置的左右最大值陣列，空間 O(n)，時間 O(n)。
2. **雙指針 (Two Pointers)**：這是空間最優解。  
   我們維護兩個指針 `left` 和 `right`，以及兩個變數 `left_max` 和 `right_max`。  
   核心思想是：如果 `height[left] < height[right]`，那麼對於 `left` 位置來說，雖然我們不知道右邊確切的最大值是多少，但我們知道右邊至少有一個 `height[right]` 比它現在的 `left_max`（或者 `height[left]`）要大（或者說，瓶頸一定在左邊）。  
   因此，當 `height[left]` 較小時，我們就可以確定 `left` 位置的蓄水量是由 `left_max` 決定的，計算並移動 `left`。反之亦然。  

### 解法：Two Pointers
> [!IMPORTANT]
> 思路：利用雙指針從兩端向中間逼近，維護左右邊界的最大高度，總是優先處理邊界較低的一側。

### 複雜度分析
| 維度 | 複雜度 | 說明 |
| --- | --- | --- |
| 時間複雜度 | O(n) | 只需要遍歷陣列一次。 |
| 空間複雜度 | O(1) | 僅使用常數變數。 |

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        int n = height.size();
        int left = 0;
        int left_max_height = height[0];
        int right = n - 1;
        int right_max_height = height[n-1];
        int sum = 0;
        while(left < right){
            if(height[left] <= height[right]){
                left_max_height = max(left_max_height, height[left]);

                sum += left_max_height - height[left];
                left++;
            }
            else{
                right_max_height = max(right_max_height, height[right]);

                sum += right_max_height - height[right];
                right--;
            }
        }
        

        return sum;
    }
};
```