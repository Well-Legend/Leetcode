# 68. Text Justification

**Link**: https://leetcode.com/problems/text-justification/  
**Tags**: Array, String, Simulation  
**Difficulty**: Hard

## 題目解釋
給定一個單詞陣列 `words` 和一個長度 `maxWidth` ，重新排版單詞，使其成為每行恰好有 `maxWidth` 個字符，且左右兩端對齊（Justify）。  
你需要遵循以下規則：  
1. 使用盡可能多地單詞填滿每一行。
2. 平攤單詞間的空格。如果一行中的空格不能均勻分配，則左側的間隔應比右側的間隔多分配一個空格。
3. 最後一行應為左對齊，單詞之間不需要插入額外的空格，行末可以直接填充空格。

## 限制與條件
- `1 <= words.length <= 300`  
- `1 <= words[i].length <= 20`  
- `words[i]` 由小寫英文字母組成  
- `1 <= maxWidth <= 100`

## 解法思路
### 思考過程
這是一個純粹的模擬題，主要考驗對邊界條件和細節的處理。  
我們可以將處理過程分為幾個步驟：
1. **分組**：確定哪些單詞可以放在同一行。條件是 `sum(words length) + count(spaces) <= maxWidth`。
2. **排版**：對於每一行，根據單詞數量和剩餘空間來分配空格。
   - **最後一行**：特殊處理，單詞之間只放一個空格，剩餘空間全補在行尾。
   - **只有一個單詞的行**：該單詞左對齊，剩餘空間全補在行尾。
   - **普通行**：計算總共需要填充的空格數 `total_spaces = maxWidth - sum(words length)`。
     - 間隔數 `gaps = word_count - 1`。
     - 每個間隔的基本空格數 `spaces = total_spaces / gaps`。
     - 需要多加一個空格的間隔數 `extra = total_spaces % gaps`（前 `extra` 個間隔多加一個空格）。

代碼實現細節：
- 使用 `sum` 記錄當前行單詞的總長度（包含每個單詞間預設的1個空格）。
- 雙層迴圈：外層控制行，內層確定該行的單詞範圍 `[i, j]`。
- 根據 `j` 是否走到最後一個單詞，或該行只有一個單詞，來區分處理邏輯。

### 解法：Simulation
> [!IMPORTANT]
> 思路：貪婪地選取每行單詞，然後分類討論（最後一行/單詞行/普通行）來計算並填充空格。

### 複雜度分析
| 維度 | 複雜度 | 說明 |
| --- | --- | --- |
| 時間複雜度 | O(n) | n 為所有單詞的字符總數。需要遍歷所有單詞並構建結果字串。 |
| 空間複雜度 | O(n) | 需要存儲結果，以及構建過程中的臨時字串。 |

```cpp
class Solution {
public:
    vector<string> fullJustify(vector<string>& words, int maxWidth) {
        vector<string> ans;

        int sum=0;
        int space_width=0, extra, i=0;
        while(i<words.size()){
            sum += words[i].size()+1;
            int j=i;
            string tmp;
            while((sum-1)<=maxWidth){
                j++;
                if (j == words.size()){
                    for(int k=i; k<j; k++){
                        tmp += words[k];
                        if(k == j-1){
                            while(maxWidth-tmp.size()>0){
                                tmp += ' ';
                            }
                            ans.push_back(tmp);
                            return ans;
                        }
                        tmp += ' ';
                    }
                }
                sum += words[j].size()+1;
            }
            sum -= words[j].size()+1;
            j--;
            if (j == i){
                tmp += words[i];
                while(maxWidth-tmp.size()>0){
                    tmp += ' ';
                }
            }
            else{
                space_width = (maxWidth-sum+1)/(j-i)+1;
                extra = (maxWidth-sum+1)%(j-i);
                for(int k=i; k<=j; k++){
                    tmp += words[k];
                    if(k!=j){
                        for(int a=0; a<space_width; a++){
                            tmp += ' ';
                        }
                        if (extra>0){
                            tmp += ' ';
                            extra--;
                        }
                    }
                }
            }
            
            ans.push_back(tmp);
            i = j+1;
            sum = 0;
        }
        return ans;
    }
};
```