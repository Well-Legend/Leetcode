# 135. Candy

**Link**: https://leetcode.com/problems/candy/  
**Tags**: Array, Greedy  
**Difficulty**: Hard

## 題目解釋
有 `n` 個孩子站成一排。給你一個整數陣列 `ratings` 表示每個孩子的評分。  
你需要按照以下要求，給這些孩子分發糖果：
1. 每個孩子至少分配到 1 個糖果。
2. 相鄰的孩子中，評分高的孩子必須獲得更多的糖果。

請你返回需要準備的 **最少** 糖果數目。

## 限制與條件
- `n == ratings.length`
- `1 <= n <= 2 * 10^4`
- `0 <= ratings[i] <= 2 * 10^4`

## 解法思路
### 思考過程
這題要求滿足「相鄰」的條件，同時要總糖果數最少。  
我們可以把條件拆解成兩個方向：
1. **左到右**：如果右邊的孩子評分比左邊高 (`ratings[i] > ratings[i-1]`)，那麼右邊孩子的糖果數應該比左邊多（至少多 1）。
2. **右到左**：如果左邊的孩子評分比右邊高 (`ratings[i] > ratings[i+1]`)，那麼左邊孩子的糖果數應該比右邊多。

解法策略可以是：
1. 初始化所有孩子都分 1 個糖果。
2. **第一遍掃描（左向右）**：只比較左邊鄰居。如果 `ratings[i] > ratings[i-1]`，則 `candy[i] = candy[i-1] + 1`。
3. **第二遍掃描（右向左）**：只比較右邊鄰居。如果 `ratings[i] > ratings[i+1]`，則 `candy[i]` 至少要比 `candy[i+1]` 多 1。但同時也要滿足左邊掃描的結果，所以我們取 `candy[i] = max(candy[i], candy[i+1] + 1)`。
4. 最後累加所有糖果數。

這樣就能同時滿足兩個方向的條件，且保證糖果數最少。

### 解法：Two-Pass Greedy
> [!IMPORTANT]
> 思路：兩次遍歷，第一次確保「右邊評分高得到的比較多」，第二次確保「左邊評分高得到的比較多」，取兩者限制的最大值。

### 複雜度分析
| 維度 | 複雜度 | 說明 |
| --- | --- | --- |
| 時間複雜度 | O(n) | 進行了兩次線性掃描。 |
| 空間複雜度 | O(n) | 需要一個陣列存儲每個孩子的糖果數。 |

```cpp
class Solution {
public:
    int candy(vector<int>& ratings) {
        int n = ratings.size();
        vector<int> candy(n,1);
        int sum = 0;
        for (int i=1; i<n; i++){
            if (ratings[i] > ratings[i-1]){
                candy[i] = candy[i-1]+1;
            }
        }
        for (int i=n-2; i>=0; i--){
            if(ratings[i]>ratings[i+1]){
                candy[i] = max(candy[i], candy[i+1]+1);
            }
        }
        for (int i=0; i<n; i++){
            sum += candy[i];
        }
        return sum;
    }
};
```
